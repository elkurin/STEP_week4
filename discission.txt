課題
1.収束しない
	最小ケースは
	3 A B C 4 A B B A A C C A
	(これ以下が存在しないことは、まずノード数が1, 2では必ず収束、3でも辺がこれ以下だとないことが列挙で分かる)

1.1 それまでのrankの合計を保存しておき、これをstep数で割ったものをrankとすればよい
	rankの点数の付け方は、初期状態をすべて100点ではなく1/N点とすれば、まさに確率遷移そのものである
	ゆえに、M回遷移した最終的な結果は、初期状態の点数を持つベクトルvに、
	i->jにうつる確率を
	Cji = 1 / (iから移動するノードの数の和、もしこれが0のときはCii = 1として他を0とする)
	と書いた行列CのM乗をかけたものとなる  ans = C^M * v
	すると、C^Mは、M->∞のとき、収束する、発散する、振動するのいずれか
	発散するとなるとansの各合計がvと一致せず矛盾するので、収束か振動のいずれかになる
	つまり、収束しないケースというのは、振動するケースと考えてよい

	以下、1.1の最初に述べた解決策でうまくいくことを考えていく

	まず収束するとき、
	limRank = aとすると、lim(1/N) * ΣRank = aなので、この計算方法で正しい結果が得られる（ただし、少々収束が遅くなる）

	次に振動するとき
	振動する時は周期がある(ような気がする)
	振動周期をNとすると、N回回転したときの和の平均というのは、全ての事象の重ね合わせとなり、妥当のように思える
	そして、M->∞なら、N/M->0と分かるので、M%NはMに対して十分小さくなり無視できる
	(ただ循環しない可能性はありそうで、r*nについて、例えばrを複素平面に拡張すると、r = cos(M_PI/(無理数)) + i*sin(M_PI/(無理数))だと永遠に循環する。それと同じように行列の場合でも存在しそう。そうすると、上の議論は成立しないが、それまでの合計を保存しておくスタイルは悪くはなさそうと感じる。未解決なので、なにか進展があり次第また追加する。)

	以上より、あまり厳密でないが、「それまでのrankの合計を保存しておき、これをstep数で割ったものをrankとすればよい」が、収束しない時にも活用できるような気がする


2.それまでのrankの平均とそのステップでのrankの差がdeltaより小さくなったら止める
	一番単純なのは、直前のrankの値を保存して、それとの差がdelta以下になったら止めるというもの(deltaはベクトル)
	しかし、これだと例えば、1のように循環するケースの場合、永遠にdelta以下にならないものが存在するし、そうでなくても収束にかなり時間がかかる場合はずっと回しつづける訳にも行かない
	なので、次に単純なのはdelta以下になったら止めるとともに、定数Cを定めてC*Nステップ(もしかしたらC*N*Nとかかも)を越えたら止める、という制約をつける必要がある
	しかし、これもあまり解析的に、妥当とは分からない
	例えば、循環系である2stepはかなり近い値を出すが、さらに回すと結構違う値になる場合などがあり、この場合結果がおかしくなる
	なので、「それまでのrankの平均とそのステップでのrankの差がdeltaより小さくなったら止める」という方式が良い
	また、この方式でも、収束にかなり時間がかかる場合等はどこかで打ちきって止める必要があるので、大量のテストケースを消化して、C*Nステップ以上なら大丈夫そうという、Cを見つけて、ステップはC*Nまでなどの条件を入れるのが良い


3.高速化日記
	まずはごく普通に実装した
	するとO(M*step)になるが、そんなに遅くない
	ここで行列積であることに気づいたので、べき乗をlog(step)で出来るというやつを実装してみた

	結論:
	普通に書いた方が、圧倒的に、速い。(それはそう)
	networkがものすごく複雑で、辺の数が多いときはmatrix.cppの方が速い
	同じ出発点から同じ着地点に行く辺が多いときなどもmatrix計算の方が速い


4.pagerankアルゴリズムの疑問点
このpagerankでは、矢印が出ていないかつ矢印が入ってこないノードはずっと自分の点に得点が残りつづけることになり、他のページとリンクしているページに比べて得点が高くなってしまうことがあるが、これは少しおかしな結果じゃないかと感じる（高い方しかみないから良いのかもしれない）
また、矢印が出るものと出ないものとで得点の割り振りかたルールが変わってしまう（矢印が一本でも出てる場合はCiiにあたる係数が0だが、まったく出ていない場合はCii=1になる）ので、少しルールとして欠陥がありそうな気がする
また、元論文にあたって、このルールの妥当性や数学的証明パート、あるいはもう少し複雑なルールになっているならそのルールを調べてみたいと思う


